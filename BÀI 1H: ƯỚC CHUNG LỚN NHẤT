Cho dãy số A[] có N phần tử. Nhiệm vụ của bạn là hãy tìm 2 số nguyên trong dãy số sao cho UCLN của chúng là lớn nhất có thể.

Input:

Dòng đầu tiên là số lượng bộ test T (T ≤ 20).

Mỗi test bắt đầu bởi số nguyên dương N (1 ≤ N ≤ 100 000).

Dòng tiếp theo gồm N số nguyên A[i] (1 ≤ A[i] ≤ 106).

Output: 

Với mỗi test, in ra UCLN chung lớn nhất tìm được trên một dòng.

#include<bits/stdc++.h>
using namespace std;

#define testcase cin>>tc;while(tc--)
#define xd cout<<endl
int tc;


void read() {
    freopen("data.txt", "r",stdin);
    // freopen("data.out", "w",stdout);
}

const long MAX = 1e6;
vector<bool> prime(MAX + 1, true);

void sieve() {
    prime[0] = prime[1] = false;
    for (long i = 2; i <= sqrt(MAX); i++) {
        if (prime[i]) {
            for (long j = i * i; j <= MAX; j += i) prime[j] = false;
        }
    }
}

int findMaxGCD(const vector<int> &arr) {
    int n = arr.size();
    int max_val = *max_element(arr.begin(), arr.end());

    vector<int> freq(max_val + 1, 0);

    for (int num: arr) {
        freq[num]++;
    }


    for (int g = max_val; g >= 1; g--) {
        int count = 0;
        for (int j = g; j <= max_val; j += g) {
            count += freq[j];
        }
        if (count > 1) {
            return g;
        }
    }

    return 1;
}

void solve() {
    int n;
    cin >> n;
    vector<int> arr(n);
    for (int &i: arr) cin >> i;
    sort(arr.begin(), arr.end());
    cout << findMaxGCD(arr);
    xd;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    // read();
    // sieve();
    testcase solve();
}
